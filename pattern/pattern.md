# 设计模式

在面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题。

设计模式是一套被反复使用、设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码的可靠性。设计模式使代码编制真正的工程化。

S.O.L.I.D

|简写|全拼|中文翻译|
|:--:|:--:|:--:|
| SRP|The Single Responsibility Principle|单一责任原则|
| OCP|The Open Closed Principle|开放封闭原则|
| LSP|The Liskov Substitution Principle|里氏替换原则|
| ISP|The Interface Segregation Principle|接口分离原则|
| DIP|The Dependency Inversion Principle|依赖倒置原则|

设计模式原则：

## 单一职责

> 修改一个类的原因应该只有一个

一个类只负责一个功能领域的相应职责它用于控制类的粒度大小。一个类承担的职责越多它被复用的可能就越小，而且一个类承担的职责过多，就相当于将这个职责耦合在一起，一个职责变化会影响另一个职责。单一职责原则实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则。

通俗来讲：
一个类只负责一件事，如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这类完成其他职责的能力。

## 开放封闭原则

> 软件实体应对扩展开放，而对修改关闭

为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键通过定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能

通俗来说：
扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。
符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码

## 里氏代换原则

> 子类对象必须能够体会所有父类对象

继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。
如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

## 接口分离原则

> 不应该强迫客户依赖于它们不用的方法。

因此使用多个专门的接口比使用单一的总接口要好。

## 依赖倒置原则

> 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。
依赖于抽象意味着：

* 任何变量都不应该持有一个指向具体类的指针或者引用；
* 任何类都不应该从具体类派生；
* 任何方法都不应该覆写它的任何基类中的已经实现的方法。

## 其他常见原则

除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。

|简写|全拼|中文翻译|
|:--:|:--:|:--:|
|LOD|The Law of Demeter|迪米特法则|
|CRP|The Composite Reuse Principle|合成复用原则|
|CCP|The Common Closure Principle|共同封闭原则|
|SAP|The Stable Abstractions Principle|稳定抽象原则|
|SDP|The Stable Dependencies Principle|稳定依赖原则|

### 迪米特法则

迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

### 合成复用原则

尽量使用对象组合，而不是通过继承来达到复用的目的。

### 共同封闭原则

一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。

### 稳定抽象原则

最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。

### 稳定依赖原则

包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。

## 创建型模式（六种)

* 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模式中对象的创建和对象的使用分离，为了使软件的结构更加清晰，外接对于这些对象只需要知道他们共同的接口，而不清楚其具体实现细节，使得整个系统的设计更加符合单一职责原则
* 创建型模式在创建什么（What），由谁创建（Who），何时创建（When）等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到真个系统独立的目的

在面向对象程序设计中，工厂通常是一个用来创建其他对象的对象。工厂是构造方法的抽象，用来实现不同的分配方案。
有时，特定类型对象的控制过程比简单地创建一个对象更复杂。在这种情况下，工厂对象就派上用场了。工厂对象可能会动态地创建产品对象的类，或者从对象池中返回一个对象

* [简单工厂模式](simplefactory.md) 重要程度：4（5为满分）
* [工厂方法模式](factorymethod.md) 重要程度：5
* [抽象工厂模式](abstractfactory.md) 重要程度：5
* [建造者模式](build.md) 重要程度：2
* [原型模式](prototype.md) 重要程度：3
* [单例模式](singleton.md) 重要程度：4

## 结构型模式Structural Pattern（七种）

* 描述如何将类或者对象结合在一起形成更大的结构，通过简单的组合形成复杂的、功能更为强大的结构
* 结构型模式可以分为类结构型模式和对象结构型模式
  * 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系
  * 对象结构型关心类和对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构性模式都是对象结构型模式

* [适配器模式](adapter.md) 重要程度：4
* [桥接模式](bridge.md) 重要程度：3
* [组合模式](composite.md) 重要程度：4
* [装饰模式](decorator.md) 重要程度：3
* [外观模式](facade.md) 重要程度：5
* [享元模式](flyweight.md) 重要程度：1
* [代理模式](proxy.md) 重要程度：4

## 行为型模式Behavioral Pattern(十一种)

* 是对不同的对象之间划分责任和算法的抽象化
* 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用
* 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一些对象在运行时也会影响到其他对象的运行

* [责任链模式](chainofresponsibility.md) 重要程度：3
* [命令模式](command.md) 重要程度：4
* [解释器模式](interpreter.md) 重要程度：1
* [迭代器模式](inerator.md) 重要程度：5
* [中介模式](mediator.md) 重要程度：2
* [备忘录模式](memento.md) 重要程度：2
* [观察者模式](observer.md) 重要程度：5
* [状态模式](state.md) 重要程度：3
* [策略模式](strategy.md) 重要程度：4
* [模板方法模式](templatemethod.md) 重要程度：3
* [访问者模式](visitor.md) 重要程度 1

## 附

* [委托模式](delegation.md)
