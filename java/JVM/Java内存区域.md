# Java内存区域

## 运行时数据区域

![jdk_1_8_before](/img/jdk_1_8_before.png)

![jdk_1_8_jvm](/img/jdk_1_8_jvm.png)

**线程私有的**：

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的**：

- 堆
- 方法区
- 直接内存（非运行时数据区的一部分）

## 程序计数器

程序计数器是一块较小的内存空间，可以当做当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。

## Java虚拟机栈

Java虚拟机也是线程私有的，它的生命周期和线程相同，描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

Java内存可以粗糙的分为堆内存（Heap）和栈内存（Stack），其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。

局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、 char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是；一个指向对象其实地址的引用指针）

## 内存的分配

一个对象从被创建到回收，主要经历阶段有：

1. 创建阶段（Created）
2. 应用阶段（In Use）
3. 不可见阶段（Invisible）
4. 不可达阶段（Unreachable）
5. 收集阶段（Collected）
6. 终结阶段（Finalized）
7. 对象空间重分配阶段（De-allocated）

内存的分配是在创建阶段，这个阶段先用类加载器加载目标class，当通过加载器检测后，就开始为新对象分配内存。对象分配内存大小在类加载完成后便可以确定。
当初始化完成后，虚拟机还要对对象进行必要的设置，如那个类的实例，如何查找元数据、对象的GC年代等。

## 内存的回收

那些不可能再被任何途径使用的对象，需要被回收，否则内存迟早都会被消耗空。
GC机制主要通过可达性分析法，通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链时，即GC Roots到对象不可达，则证明此对象是不可达的。

可作为GC Root的地方如下：

- 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象
- 方法去中的类静态属性引用的对象
- 方法去中常量引用的对象
- 本地方法栈中JNI（Native方法）引用的对象
  
当一个对象或几个相互引用的对象组没有任何引用链时，会被当成垃圾处理，可以进行回收。
如果一个对象在程序中已经不再使用，但是（强）引用还是会其他对象持有，则成为内存泄露。

## 引用的分类

1. 强引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象
2. 软引用，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。SoftReference表示软引用
3. 弱引用，只要有GC，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference表示弱引用
4. 虚引用，这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时候完全没有关系。PhantomReference表示虚引用，需要搭配ReferenceQueue使用，检测对象回收情况。
